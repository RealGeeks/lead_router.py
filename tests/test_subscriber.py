import json
import re
from contextlib import contextmanager

import mock
import httpretty
import pytest

from leadrouter.subscriber import Subscriber, RETRY_DELAY, STATUS_NO_RETRY


@httpretty.activate
def test_handle():
    httpretty.register_uri(httpretty.POST, re.compile(r'.*'))

    job = mock.Mock(['delete'])
    job.jid = 'j1'
    job.body = VALID_JOB_BODY

    sub = Subscriber()
    sub.handle(job)

    job.delete.assert_called_once_with()
    assert_request_made_from_valid_job_body(httpretty.last_request())

@httpretty.activate
def test_handle_retry():
    httpretty.register_uri(httpretty.POST, re.compile(r'.*'), status=503)

    job = mock.Mock(['release'])
    job.jid = 'j1'
    job.body = VALID_JOB_BODY

    sub = Subscriber()
    sub.handle(job)

    job.release.assert_called_once_with(delay=RETRY_DELAY)

@httpretty.activate
def test_handle_no_retry():
    httpretty.register_uri(httpretty.POST, re.compile(r'.*'), status=STATUS_NO_RETRY[0])

    job = mock.Mock(['delete'])
    job.jid = 'j1'
    job.body = VALID_JOB_BODY

    sub = Subscriber()
    sub.handle(job)

    job.delete.assert_called_once_with()

def test_handle_invalid_job():
    job = mock.Mock(['delete'])
    job.body = 'invalid'  # fail to parse job

    sub = Subscriber()
    sub.handle(job)

    job.delete.assert_called_once_with()

def test_handle_job_with_invalid_client_method():
    job = mock.Mock(['delete', 'jid'])
    job.jib = '123'
    job.body = JOB_BODY_INVALID_METHOD  # parsed job but json has invalid Client method

    sub = Subscriber()
    sub.handle(job)

    job.delete.assert_called_once_with()

def test_handle_job_with_json_without_any_required_keys():
    job = mock.Mock(['delete', 'jid'])
    job.jib = '123'
    job.body = JOB_BODY_MISSING_KEYS # parsed job but json is missing all keys

    sub = Subscriber()
    sub.handle(job)

    job.delete.assert_called_once_with()

def test_consume():
    '''consume is the main entrypoint of Subscriber, just make sure it's calling
    handle() for every loop iteration'''

    job = object()

    s = Subscriber()

    # mock beanstalkd connection
    s.queue = mock.Mock(['reserve'])
    s.queue.reserve.return_value = job

    # mock handle(), let it be from an infinite loop a few times
    s.handle = mock.Mock()
    s.handle.side_effect = call_in_loop()

    with called_in_loop():
        s.consume()

#
# helpers
#

VALID_JOB_BODY = json.dumps({
    'host': 'api.com',
    'auth': ['user', 'token'],
    'method': 'create_lead',
    'params': {
        'site_uuid': '123-abc',
        'lead': {'email': 'lead@gmail.com'},
    },
})

JOB_BODY_INVALID_METHOD = json.dumps({
    'host': 'api.com',
    'auth': ['user', 'token'],
    'method': 'client_doesnt_have_this_method',
    'params': {},
})

JOB_BODY_MISSING_KEYS = json.dumps({})

def assert_request_made_from_valid_job_body(request):
    '''Assert the given httpretty request was made using VALID_JOB_BODY spec'''
    assert request.path == '/rest/sites/123-abc/leads'
    assert request.method == 'POST'
    assert request.body == '{"email": "lead@gmail.com"}'
    assert request.headers['Host'] == 'api.com'
    assert request.headers['Authorization'] == 'Basic dXNlcjp0b2tlbg=='
    assert request.headers['Content-Type'] == 'application/json; charset=utf-8'

def call_in_loop():
    '''Return a function to be called 3 times inside a loop, after that will
    raise RuntimeError

    Use called_in_loop() context manager to ensure the function was called
    as expected
    '''
    calls = []
    def handle(job):
        calls.append(1)
        if len(calls) == 3:
            raise RuntimeError('testing: stop loop')
    return handle

@contextmanager
def called_in_loop():
    '''Ensure function generated by call_in_loop() was called until exhaustion'''
    with pytest.raises(RuntimeError) as exc_info:
        yield
    assert str(exc_info.value) == 'testing: stop loop'
